-- NOTE the name of this file is temporary. Eventually code in this file will be reorganized

import mlda.Base
import mlda.Three

variable
  {Value : Type}
  [Fintype Value]
  -- [Nonempty Value] -- TODO is this needed?
  [DecidableEq Value]

namespace Definitions

variable
  (f : Value â†’ ğŸ¯)
  (v v' : Value)

open scoped Three.Atom
open Three

def allValues : Finset Value := Finset.univ

omit [DecidableEq Value] in
@[simp] theorem in_allValues : v âˆˆ allValues := Finset.mem_univ v

abbrev veq : ğŸ¯ := if v = v' then true else false
scoped infix:4 " â‰¡ " => veq

@[simp] def and_implies_eq : ğŸ¯ := (f v âˆ§ f v') â†’ (v â‰¡ v')

@[simp] def and_implies_eq_all : ğŸ¯ :=
  allValues |>.fold min true fun v' => and_implies_eq f v v'

def existence : ğŸ¯ := allValues |>.fold max false f
scoped notation " âˆƒâ " => existence

def existence_affine : ğŸ¯ := allValues |>.fold min true (and_implies_eq_all f)
scoped notation " âˆƒâ‚€â‚ " => existence_affine

def existence_unique : ğŸ¯ := existence f âˆ§ existence_affine f
scoped notation " âˆƒâ‚ " => existence_unique

end Definitions

open Definitions

namespace Lemmas

variable
  {f : Value â†’ ğŸ¯}
  {v v' : Value}

omit [Fintype Value] in
@[simp] theorem veq_true : (v â‰¡ v') = .true â†” v = v' := by simp

omit [Fintype Value] in
@[simp] theorem veq_false : (v â‰¡ v') = .false â†” v â‰  v' := by simp

omit [Fintype Value] in
@[simp] theorem veq_refl : (v â‰¡ v) = .true := by simp

omit [Fintype Value] in
@[simp] theorem veq_byzantine_le: .byzantine â‰¤ (v â‰¡ v') â†” (v â‰¡ v') = .true := by
  if h : v = v'
  then simp [h]
  else simp [veq_false.mpr h]

omit [Fintype Value] in
@[simp] theorem veq_le_byzantine : (v â‰¡ v') â‰¤ .byzantine â†” (v â‰¡ v') = .false := by
  if h : v = v'
  then simp [h]
  else simp [veq_false.mpr h]

omit [Fintype Value] in
@[simp] theorem veq_ne_byzantine : (v â‰¡ v') â‰  .byzantine := by
  if h : v = v'
  then simp [h]
  else simp [veq_false.mpr h]

end Lemmas

namespace Remark_3_1_2

open scoped Three.Atom
open Lemmas

variable
  {f : Value â†’ ğŸ¯}
  {v v' : Value}

theorem t1 : f v = .true â†’ f v' = .true â†’ v â‰  v'
  â†’ âˆƒâ‚€â‚ f = .false := by
  intro v1 v2 n
  simp [existence_affine]
  exists v;
  exists v'; simp [v1, v2, Lemmas.veq_false.mpr n]

theorem t2 : (âˆƒ! v, f v = .true) â†’ (âˆ€ v', f v' â‰  .byzantine) â†’ âˆƒâ‚ f = .true := by
  rintro âŸ¨t, ft, h1âŸ© h2
  simp [existence_unique, Three.Lemmas.and_true]; constructor
  simp [existence]
  exists t
  simp [existence_affine, and_implies_eq_all, and_implies_eq]; intro x y
  have hx := h2 x; have hy := h2 y
  cases fx : f x <;> first | contradiction | simp
  cases fy : f y <;> first | contradiction | simp
  simp [h1 x fx, h1 y fy]

theorem t3 : (âˆƒ! v, f v = .true) â†’ f v' = .byzantine
  â†’ âˆƒâ‚ f = .byzantine âˆ§ âˆƒâ‚€â‚ f = .byzantine := by
  rintro âŸ¨v, vt, hvâŸ© h2
  have affine : âˆƒâ‚€â‚ f = .byzantine := by
    simp [existence_affine]
    constructor
    intro x; intro y
    rw [Three.Lemmas.byzantine_le]
    cases fx : f x <;> cases fy : f y <;> first | contradiction | simp <;> try exact ne_or_eq x y
    simp [hv x fx, hv y fy]
    exists v'; constructor; intro y
    cases fy : f y <;> first | contradiction | simp [h2]
    exists v; simp [h2, vt]; intro e; rw [e, vt] at h2; contradiction
  constructor; simp [existence_unique, affine, existence, Three.Lemmas.le_join]
  exists v'; simp [h2]; exact affine

-- NOTE I think this theorem is not entirely true and not needed (see pdf). I think it should be removed. It is superseded by t5
-- theorem t4 : (âˆ€ v, f v â‰¤ .byzantine) â†’ (âˆƒ! v', f v' = .byzantine) â†’ âˆƒâ‚ f = .byzantine âˆ§ âˆƒâ‚€â‚ f = .byzantine := by

theorem t5 : (âˆ€ v, f v â‰¤ .byzantine) â†’ v â‰  v' â†’ f v = .byzantine â†’ f v' = .byzantine â†’ âˆƒâ‚ f = .byzantine := by
  rintro p ne fv fv'
  have affine : âˆƒâ‚€â‚ f = .byzantine := by
    simp [existence_affine]
    constructor
    Â· intro x y
      rw [Three.Lemmas.byzantine_le]
      cases fx : f x <;> cases fy : f y <;> first | contradiction | simp <;> try exact ne_or_eq x y
      have := p x; rw [fx] at this; contradiction
    Â· exists v; simp [fv]; constructor
      intro y; simp [Three.Lemmas.byzantine_le_impl];
      exists v'; simp [veq_false.mpr ne, fv']
  simp [existence_unique, affine, existence, Three.Lemmas.le_join]
  exists v; simp [fv]

theorem t6 : (âˆ€ v, f v = .false) â†’ âˆƒâ‚ f = .false âˆ§ âˆƒâ‚€â‚ f = .true := by
  intro h
  have affine : âˆƒâ‚€â‚ f = .true := by simp [existence_affine]; intro x y; simp [h x, h y]
  have ex : âˆƒâ f = .false := by simpa [existence]
  have unique : âˆƒâ‚ f = .false := by simp [existence_unique, ex]
  exact âŸ¨unique, affineâŸ©

end Remark_3_1_2

namespace Proposition_3_1_3

open Three.Atom

variable
  (f : Value â†’ ğŸ¯)
  {v v' : Value}

namespace Part_1

abbrev p_A := âŠ¨ (âˆƒâ‚€â‚ f)
abbrev p_B := .byzantine â‰¤ âˆƒâ‚€â‚ f
abbrev p_C := âˆƒ? v, âŠ¨ (T (f v))
abbrev p_D := âˆƒ? v, f v = .true
abbrev p_E := âˆ€ v v', f v = .true â†’ f v' = .true â†’ v = v'

theorem A_B : p_A f â†’ p_B f := by simp

theorem B_C : p_B f â†’ p_C f := by
  simp [existence_affine]; intro h x y h2 h3
  simp at h2 h3; have hx := h x y; simpa [h2, h3] using hx

omit [Fintype Value] [DecidableEq Value] in
theorem C_D : p_C f â†’ p_D f := by simp [p_C]

omit [Fintype Value] [DecidableEq Value] in
theorem D_E : p_D f â†’ p_E f := by
  simp [p_D, p_E]; intro h x y fx fy
  exact h fx fy

theorem E_A : p_E f â†’ p_A f := by
  simp [p_E, existence_affine]; intro h x y
  cases fx : f x <;> cases fy : f y <;> first | contradiction | simp
  simp [h x y fx fy]

end Part_1

namespace Part_2

abbrev P_A := âŠ¨ (âˆƒâ‚ f)
abbrev P_B := (âˆƒ v, âŠ¨ (f v)) âˆ§ âŠ¨ (âˆƒâ‚€â‚ f)

theorem A_B : P_A f â†” P_B f := by
  simp [P_B]; constructor
  Â· intro h
    simp [existence_unique, existence, existence_affine, Three.Lemmas.le_and] at h
    obtain âŸ¨h1, h2âŸ© := h
    simp [existence_affine]
    constructor <;> assumption
  Â· intro âŸ¨h1, h2âŸ©
    rw [existence_unique]
    apply Three.Lemmas.le_and.mpr
    constructor
    Â· simpa [existence]
    Â· assumption

end Part_2

namespace Part_3

abbrev P_A := âŠ¨ (T (âˆƒâ‚€â‚ f))
abbrev P_B := (âˆƒ? v, f v = .true) âˆ§ (âˆ€ v, f v â‰  .byzantine)

-- theorem A_B : P_A f â†” P_B f := by
--   simp [P_B]; constructor
--   Â· intro h
--     simp [existence_affine] at h
--     constructor
--     Â· intro a b ta tb;
--       simpa [ta, tb] using h a b
--     Â· intro v b
--       sorry
      
  --   obtain âŸ¨âŸ¨u, fuâŸ©, h2âŸ© := h
  --   constructor; 
  --   Â· intro a b ta tb
  --     simpa [ta, tb] using h2 a b
  --   Â· intro v e
  --     have p := h2 u v
  --     have uv : u â‰  v := sorry
  --     conv at p => left; right; rw [Lemmas.veq_false.mpr uv]
  --     simp [Three.Lemmas.and_false] at p; cases p
  --     next h => rw [fu] at h; contradiction
  --     next h => rw [e] at h; contradiction
  -- Â· rintro âŸ¨h1, h2âŸ©
  --   simp [existence_unique, Three.Lemmas.and_true, existence, existence_affine]; constructor
  --   Â· 
end Part_3

namespace Part_4

abbrev P_A := âŠ¨ (T (âˆƒâ‚ f))
abbrev P_B := (âˆƒ! v, f v = .true) âˆ§ (âˆ€ v, f v â‰  .byzantine)

theorem A_B : P_A f â†” P_B f := by
  simp [P_B]; constructor
  Â· intro h; simp [existence_unique, Three.Lemmas.and_true, existence, existence_affine] at h
    obtain âŸ¨âŸ¨u, utâŸ©, h2âŸ© := h; constructor
    Â· exists u; constructor; assumption
      intro v vt
      simpa [Three.Lemmas.and_true, ut, vt] using Three.Lemmas.mp_weak (h2 v u)
    Â· intro v vb
      have e := by simpa [ut, vb] using h2 u v
      rw [e] at ut; rw [ut] at vb; contradiction
  rintro âŸ¨âŸ¨u, ut, uuâŸ©, h2âŸ©
  simp [existence_unique, Three.Lemmas.and_true, existence, existence_affine]; constructor
  Â· exists u
  Â· intro x y; simp [Three.Lemmas.or_true]
    if xy : x = y then right; assumption
    else left; simp [Three.Lemmas.and_false]
         cases fx : f x <;> cases fy : f y <;> first | contradiction | simp
         exact h2 x fx; exact h2 x fx; exact h2 y fy
         have xt := uu _ fx
         have yt := uu _ fy
         rw [â† yt] at xt; contradiction

end Part_4

end Proposition_3_1_3
